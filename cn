1.
Star Topology
#Create a simulator object
set ns [new Simulator]
#Open the nam trace file
set nf [open out.nam w]
$ns namtrace-all $nf
#Define a 'finish' procedure
proc finish {} {
 global ns nf
 $ns flush-trace
 #Close the trace file
 close $nf
 #Executenam on the trace file
 exec nam out.nam &
 exit 0
}
#Create six nodes
set n0 [$ns node]
set n1 [$ns node]
set n2 [$ns node]
set n3 [$ns node]
set n4 [$ns node]
set n5 [$ns node]
#Change the shape of center node in a star topology
$n0 shape square
#Create links between the nodes
$ns duplex-link $n0 $n1 1Mb 10ms DropTail
$ns duplex-link $n0 $n2 1Mb 10ms DropTail
$ns duplex-link $n0 $n3 1Mb 10ms DropTail
$ns duplex-link $n0 $n4 1Mb 10ms DropTail
$ns duplex-link $n0 $n5 1Mb 10ms DropTail
#Create a TCP agent and attach it to node n0
set tcp0 [new Agent/TCP]
$tcp0 set class_ 1
$ns attach-agent $n1 $tcp0
#Create a TCP Sink agent (a traffic sink) for TCP and attach it to node n3
set sink0 [new Agent/TCPSink]
$ns attach-agent $n3 $sink0
#Connect the traffic sources with the traffic sink
$ns connect $tcp0 $sink0
# Create a CBR traffic source and attach it to tcp0
set cbr0 [new Application/Traffic/CBR]
$cbr0 set packetSize_ 500
$cbr0 set interval_ 0.01
$cbr0 attach-agent $tcp0
#Schedule events for the CBR agents
$ns at 0.5 "$cbr0 start"
$ns at 4.5 "$cbr0 stop"
#Call the finish procedure after 5 seconds of simulation time
$ns at 5.0 "finish"
#Run the simulation
$ns run

Bus Topology
#Create a simulator object
set ns [new Simulator]
#Open the nam trace file
set nf [open out.nam w]
$ns namtrace-all $nf
#Define a 'finish' procedure
proc finish {} {
 global ns nf
 $ns flush-trace
 #Close the trace file
 close $nf
 #Executenam on the trace file
 exec nam out.nam &
 exit 0
}
#Create five nodes
set n0 [$ns node]
set n1 [$ns node] 
set n2 [$ns node]
set n3 [$ns node]
set n4 [$ns node]
#Create Lan between the nodes
set lan0 [$ns newLan "$n0 $n1 $n2 $n3 $n4" 0.5Mb 40ms LL Queue/DropTail
MAC/Csma/Cd Channel]
#Create a TCP agent and attach it to node n0
set tcp0 [new Agent/TCP]
$tcp0 set class_ 1
$ns attach-agent $n1 $tcp0
#Create a TCP Sink agent (a traffic sink) for TCP and attach it to node n3
set sink0 [new Agent/TCPSink]
$ns attach-agent $n3 $sink0
#Connect the traffic sources with the traffic sink
$ns connect $tcp0 $sink0
# Create a CBR traffic source and attach it to tcp0
set cbr0 [new Application/Traffic/CBR]
$cbr0 set packetSize_ 500
$cbr0 set interval_ 0.01
$cbr0 attach-agent $tcp0
#Schedule events for the CBR agents
$ns at 0.5 "$cbr0 start"
$ns at 4.5 "$cbr0 stop"
#Call the finish procedure after 5 seconds of simulation time
$ns at 5.0 "finish"
#Run the simulation
$ns run


Ring Topology
#Create a simulator object
set ns [new Simulator]
#Open the nam trace file
set nf [open out.nam w]
$ns namtrace-all $nf
#Define a 'finish' procedure
proc finish {} {
 global ns nf
 $ns flush-trace
 #Close the trace file
 close $nf
 #Executenam on the trace file
 exec nam out.nam &
 exit0
}
#Create five nodes
set n0 [$ns node]
set n1 [$ns node]
set n2 [$ns node]
set n3 [$ns node]
set n4 [$ns node]
set n5 [$ns node]
#Create links between the nodes
$ns duplex-link $n0 $n1 1Mb 10ms DropTail
$ns duplex-link $n1 $n2 1Mb 10ms DropTail
$ns duplex-link $n2 $n3 1Mb 10ms DropTail
$ns duplex-link $n3 $n4 1Mb 10ms DropTail
$ns duplex-link $n4 $n5 1Mb 10ms DropTail
$ns duplex-link $n5 $n0 1Mb 10ms DropTail
#Create a TCP agent and attach it to node n0
set tcp0 [new Agent/TCP]
$tcp0 set class_ 1
$ns attach-agent $n1 $tcp0
#Create a TCP Sink agent (a traffic sink) for TCP and attach it to node n3
set sink0 [new Agent/TCPSink]
$ns attach-agent $n3 $sink0
#Connect the traffic sources with the traffic sink
$ns connect $tcp0 $sink0
# Create a CBR traffic source and attach it to tcp0
set cbr0 [new Application/Traffic/CBR]
$cbr0 set packetSize_ 500
$cbr0 set interval_ 0.01
$cbr0 attach-agent $tcp0
#Schedule events for the CBR agents
$ns at 0.5 "$cbr0 start"
$ns at 4.5 "$cbr0 stop"
#Call the finish procedure after 5 seconds of simulation time
$ns at 5.0 "finish"
#Run the simulation
$ns run

2.
Stop and Wait protocol
set ns [new Simulator]
set n0 [$ns node]
set n1 [$ns node]
$ns at 0.0 "$n0 label Sender"
$ns at 0.0 "$n1 label Receiver"
set nf [open stop.nam w]
$ns namtrace-all $nf
set f [open stop.tr w]
$ns trace-all $f
$ns duplex-link $n0 $n1 0.2Mb 200ms DropTail
$ns duplex-link-op $n0 $n1 orient right
$ns queue-limit $n0 $n1 10
Agent/TCP set nam_tracevar_ true
set tcp [new Agent/TCP]
$tcp set window_ 1
$tcp set maxcwnd_ 1
$ns attach-agent $n0 $tcp
set sink [new Agent/TCPSink]
$ns attach-agent $n1 $sink
$ns connect $tcp $sink
set ftp [new Application/FTP]
$ftp attach-agent $tcp
$ns add-agent-trace $tcp tcp
$ns monitor-agent-trace $tcp
$tcp tracevar cwnd_
$ns at 0.1 "$ftp start"
$ns at 3.0 "$ns detach-agent $n0 $tcp ; $ns detach-agent $n1 $sink"
$ns at 3.5 "finish"
$ns at 0.0 "$ns trace-annotate \"Stop and Wait with normal operation\""
$ns at 0.05 "$ns trace-annotate \"FTP starts at 0.1\""
$ns at 0.11 "$ns trace-annotate \"Send Packet_0\""
$ns at 0.35 "$ns trace-annotate \"Receive Ack_0\""
$ns at 0.56 "$ns trace-annotate \"Send Packet_1\""
$ns at 0.79 "$ns trace-annotate \"Receive Ack_1\""
$ns at 0.99 "$ns trace-annotate \"Send Packet_2\""
$ns at 1.23 "$ns trace-annotate \"Receive Ack_2 \""
$ns at 1.43 "$ns trace-annotate \"Send Packet_3\""
$ns at 1.67 "$ns trace-annotate \"Receive Ack_3\""
$ns at 1.88 "$ns trace-annotate \"Send Packet_4\""
$ns at 2.11 "$ns trace-annotate \"Receive Ack_4\""
$ns at 2.32 "$ns trace-annotate \"Send Packet_5\""
$ns at 2.55 "$ns trace-annotate \"Receive Ack_5 \""
$ns at 2.75 "$ns trace-annotate \"Send Packet_6\""
$ns at 2.99 "$ns trace-annotate \"Receive Ack_6\""
$ns at 3.1 "$ns trace-annotate \"FTP stops\""
proc finish {} {
 global ns nf
 $ns flush-trace close $nf
 puts "running nam..."
 exec nam stop.nam &
 exit 0
}
$ns run


Sliding window protocol
# sliding window mechanism with some features
# such as labeling, annotation, nam-graph, and window size monitoring
set ns [new Simulator]
set n0 [$ns node]
set n1 [$ns node]
$ns at 0.0 "$n0 label Sender"
$ns at 0.0 "$n1 label Receiver"
set nf [open sliding.nam w]
$ns namtrace-all $nf
set f [open sliding.tr w]
$ns trace-all $f
$ns duplex-link $n0 $n1 0.2Mb 200ms DropTail
$ns duplex-link-op $n0 $n1 orient right
$ns queue-limit $n0 $n1 10
Agent/TCP set nam_tracevar_ true
set tcp [new Agent/TCP]
$tcp set windowInit_ 4
$tcp set maxcwnd_ 4
$ns attach-agent $n0 $tcp
set sink [new Agent/TCPSink]
$ns attach-agent $n1 $sink
$ns connect $tcp $sink
set ftp [new Application/FTP]
$ftp attach-agent $tcp
$ns add-agent-trace $tcp tcp
$ns monitor-agent-trace $tcp
$tcp tracevar cwnd_
$ns at 0.1 "$ftp start"
$ns at 3.0 "$ns detach-agent $n0 $tcp ; $ns detach-agent $n1 $sink"
$ns at 3.5 "finish"
$ns at 0.0 "$ns trace-annotate \"Sliding Window with window size 4 (normal operation)\""
$ns at 0.05 "$ns trace-annotate \"FTP starts at 0.1\""
$ns at 0.11 "$ns trace-annotate \"Send Packet_0,1,2,3\""
$ns at 0.34 "$ns trace-annotate \"Receive Ack_0,1,2,3\""
$ns at 0.56 "$ns trace-annotate \"Send Packet_4,5,6,7\""
$ns at 0.79 "$ns trace-annotate \"Receive Ack_4,5,6,7\""
$ns at 0.99 "$ns trace-annotate \"Send Packet_8,9,10,11\""
$ns at 1.23 "$ns trace-annotate \"Receive Ack_8,9,10,11 \""
$ns at 1.43 "$ns trace-annotate \"Send Packet_12,13,14,15\""
$ns at 1.67 "$ns trace-annotate \"Receive Ack_12,13,14,15\""
$ns at 1.88 "$ns trace-annotate \"Send Packet_16,17,18,19\""
$ns at 2.11 "$ns trace-annotate \"Receive Ack_16,17,18,19\""
$ns at 2.32 "$ns trace-annotate \"Send Packet_20,21,22,23\""
$ns at 2.56 "$ns trace-annotate \"Receive Ack_24,25,26,27\""
$ns at 2.76 "$ns trace-annotate \"Send Packet_28,29,30,31\""
$ns at 3.00 "$ns trace-annotate \"Receive Ack_28\""
$ns at 3.1 "$ns trace-annotate \"FTP stops\"" 
proc finish {} {
 global ns
 $ns flush-trace
 #close $nf
 puts "running nam..."
 exec nam sliding.nam &
 exit 0
}
$ns run


3.
set ns [new Simulator]
#Tell the simulator to use dynamic routing
$ns rtproto DV
$ns macType Mac/Sat/UnslottedAloha
#Open the nam trace file
set nf [open aloha.nam w]
$ns namtrace-all $nf
#Open the output files
set f0 [open aloha.tr w]
$ns trace-all $f0
#Define a finish procedure
proc finish {} {
global ns f0 nf
$ns flush-trace
#Close the trace file
close $f0
close $nf
exec nam aloha.nam &
exit 0
}
# Create six nodes
set n0 [$ns node]
set n1 [$ns node]
set n2 [$ns node]
set n3 [$ns node]
set n4 [$ns node]
set n5 [$ns node]
# Create duplex links between nodes with bandwidth and distance
$ns duplex-link $n0 $n4 1Mb 50ms DropTail
$ns duplex-link $n1 $n4 1Mb 50ms DropTail
$ns duplex-link $n2 $n5 1Mb 1ms DropTail
$ns duplex-link $n3 $n5 1Mb 1ms DropTail
$ns duplex-link $n4 $n5 1Mb 50ms DropTail
$ns duplex-link $n2 $n3 1Mb 50ms DropTail
# Create a duplex link between nodes 4 and 5 as queue position
$ns duplex-link-op $n4 $n5 queuePos 0.5
#Create a UDP agent and attach it to node n(0)
set udp0 [new Agent/UDP]
$ns attach-agent $n0 $udp0
# Create a CBR traffic source and attach it to udp0
set cbr0 [new Application/Traffic/CBR]
$cbr0 set packetSize_ 500
$cbr0 set interval_ 0.005
$cbr0 attach-agent $udp0
#Create a Null agent (a traffic sink) and attach it to node n(2)
set null0 [new Agent/Null]
$ns attach-agent $n2 $null0
#Connect the traffic source with the traffic sink
$ns connect $udp0 $null0
#Schedule events for the CBR agent and the network dynamics
$ns at 0.5 "$cbr0 start"
$ns rtmodel-at 1.0 down $n5 $n2
$ns rtmodel-at 2.0 up $n5 $n2
$ns at 4.5 "$cbr0 stop"
#Call the finish procedure after 5 seconds of simulation time
$ns at 5.0 "finish"
#Run the simulation
$ns run

4.
#send packets one by one
set ns [new Simulator]
set n0 [$ns node]
set n1 [$ns node]
set n2 [$ns node]
set n3 [$ns node]
set n4 [$ns node]
set n5 [$ns node]
$n0 color "purple"
$n1 color "purple"
$n2 color "violet"
$n3 color "violet"
$n4 color "chocolate"
$n5 color "chocolate"
$n0 shape box ;
$n1 shape box ;
$n2 shape box ;
$n3 shape box ;
$n4 shape box ;
$n5 shape box ;
$ns at 0.0 "$n0 label SYS0"
$ns at 0.0 "$n1 label SYS1"
$ns at 0.0 "$n2 label SYS2"
$ns at 0.0 "$n3 label SYS3"
$ns at 0.0 "$n4 label SYS4"
$ns at 0.0 "$n5 label SYS5"
set nf [open goback.nam w]
$ns namtrace-all $nf 
set f [open goback.tr w]
$ns trace-all $f
$ns duplex-link $n0 $n2 1Mb 20ms DropTail
$ns duplex-link-op $n0 $n2 orient right-down
$ns queue-limit $n0 $n2 5
$ns duplex-link $n1 $n2 1Mb 20ms DropTail
$ns duplex-link-op $n1 $n2 orient right-up
$ns duplex-link $n2 $n3 1Mb 20ms DropTail
$ns duplex-link-op $n2 $n3 orient right
$ns duplex-link $n3 $n4 1Mb 20ms DropTail
$ns duplex-link-op $n3 $n4 orient right-up
$ns duplex-link $n3 $n5 1Mb 20ms DropTail
$ns duplex-link-op $n3 $n5 orient right-down
Agent/TCP set_nam_tracevar_true
set tcp [new Agent/TCP]
$tcp set fid 1
$ns attach-agent $n1 $tcp
set sink [new Agent/TCPSink]
$ns attach-agent $n4 $sink
$ns connect $tcp $sink
set ftp [new Application/FTP]
$ftp attach-agent $tcp
$ns at 0.05 "$ftp start"
$ns at 0.06 "$tcp set windowlnit 6"
$ns at 0.06 "$tcp set maxcwnd 6"
$ns at 0.25 "$ns queue-limit $n3 $n4 0"
$ns at 0.26 "$ns queue-limit $n3 $n4 10"
$ns at 0.305 "$tcp set windowlnit 4"
$ns at 0.305 "$tcp set maxcwnd 4"
$ns at 0.368 "$ns detach-agent $n1 $tcp ; $ns detach-agent $n4 $sink"
$ns at 1.5 "finish"
$ns at 0.0 "$ns trace-annotate \"Goback N end\""
$ns at 0.05 "$ns trace-annotate \"FTP starts at 0.01\""
$ns at 0.06 "$ns trace-annotate \"Send 6Packets from SYS1 to SYS4\""
$ns at 0.26 "$ns trace-annotate \"Error Occurs for 4th packet so not sent ack for the Packet\""
$ns at 0.30 "$ns trace-annotate \"Retransmit Packet_4 to 6\""
$ns at 1.0 "$ns trace-annotate \"FTP stops\""
proc finish {} {
global ns nf
$ns flush-trace
close $nf
puts "filtering..."
#exec tclsh../bin/namfilter.tcl goback.nam
#puts "running nam..."
exec nam goback.nam &
exit 0
}
$ns run

5.
#send packets one by one
set ns [new Simulator]
set n0 [$ns node]
set n1 [$ns node]
set n2 [$ns node]
set n3 [$ns node]
set n4 [$ns node]
set n5 [$ns node]
$n0 color "red"
$n1 color "red"
$n2 color "green"
$n3 color "green"
$n4 color "black"
$n5 color "black"
$n0 shape circle ;
$n1 shape circle ;
$n2 shape circle ;
$n3 shape circle ;
$n4 shape circle ;
$n5 shape circle ;
$ns at 0.0 "$n0 label SYS1"
$ns at 0.0 "$n1 label SYS2"
$ns at 0.0 "$n2 label SYS3"
$ns at 0.0 "$n3 label SYS4"
$ns at 0.0 "$n4 label SYS5"
$ns at 0.0 "$n5 label SYS6"
set nf [open Srepeat.nam w]
$ns namtrace-all $nf
set f [open Srepeat.tr w]
$ns trace-all $f
$ns duplex-link $n0 $n2 1Mb 10ms DropTail
$ns duplex-link-op $n0 $n2 orient right-down
$ns queue-limit $n0 $n2 5
$ns duplex-link $n1 $n2 1Mb 10ms DropTail
$ns duplex-link-op $n1 $n2 orient right-up
$ns duplex-link $n2 $n3 1Mb 10ms DropTail
$ns duplex-link-op $n2 $n3 orient right
$ns duplex-link $n3 $n4 1Mb 10ms DropTail
$ns duplex-link-op $n3 $n4 orient right-up
$ns duplex-link $n3 $n5 1Mb 10ms DropTail
$ns duplex-link-op $n3 $n5 orient right-down
Agent/TCP set_nam_tracevar_true
set tcp [new Agent/TCP]
$tcp set fid 1
$ns attach-agent $n1 $tcp
set sink [new Agent/TCPSink]
$ns attach-agent $n4 $sink
$ns connect $tcp $sink
set ftp [new Application/FTP]
$ftp attach-agent $tcp
$ns at 0.05 "$ftp start"
$ns at 0.06 "$tcp set windowlnit 8"
$ns at 0.06 "$tcp set maxcwnd 8"
$ns at 0.25 "$ns queue-limit $n3 $n4 0"
$ns at 0.26 "$ns queue-limit $n3 $n4 10"
$ns at 0.30 "$tcp set windowlnit 1"
$ns at 0.30 "$tcp set maxcwnd 1"
$ns at 0.30 "$ns queue-limit $n3 $n4 10"
$ns at 0.47 "$ns detach-agent $n1 $tcp;$ns detach-agent $n4 $sink"
$ns at 1.75 "finish"
$ns at 0.0 "$ns trace-annotate \"Select and repeat\""
$ns at 0.05 "$ns trace-annotate \"FTP starts at 0.01\""
$ns at 0.06 "$ns trace-annotate \"Send 8Packets from SYS1 to SYS4\""
$ns at 0.26 "$ns trace-annotate \"Error Occurs in 4th packet \""
$ns at 0.30 "$ns trace-annotate \"Retransmit Packet_4 from SYS1 to SYS4\""
$ns at 1.5 "$ns trace-annotate \"FTP stops\""
proc finish {} {
global ns nf
$ns flush-trace
close $nf
puts "filtering..."
#exec tclsh../bin/namfilter.tcl srepeat.nam
#puts "running nam..."
exec nam Srepeat.nam &
exit 0
}
$ns run


1.

#include <stdio.h>
#include <string.h>

char data[100], check_value[100], gen_poly[100];
int data_length, N, i, j;

void XOR()
{
    for (j = 1; j < N; j++)
        check_value[j] = ((check_value[j] == gen_poly[j]) ? '0' : '1');
}

void crc()
{
    for (i = 0; i < N; i++)
        check_value[i] = data[i];

    do
    {
        if (check_value[0] == '1')
            XOR();

        for (j = 0; j < N - 1; j++)
            check_value[j] = check_value[j + 1];

        if (i < data_length + N - 1)
            check_value[N - 1] = data[i];
        else
            check_value[N - 1] = '0';

        i++;
    } while (i <= data_length + N - 1);
}

void receiver()
{
    // Added newline to match your format where input is on the next line
    printf("\nEnter the received data:\n");
    scanf("%s", data);

    printf("\nData received: %s", data);

    crc();

    int error = 0;
    for (i = 0; i < N - 1; i++)
    {
        if (check_value[i] == '1')
        {
            error = 1;
            break;
        }
    }

    if (error == 0)
        printf("\n\nNo error detected\n");
    else
        printf("\n\nError detected\n");
}

int main()
{
    printf("Enter data to be transmitted: ");
    scanf("%s", data);

    // Added newline to match your format
    printf("\nEnter the Generating polynomial:\n");
    scanf("%s", gen_poly);

    data_length = strlen(data);
    N = strlen(gen_poly);

    for (i = data_length; i < data_length + N - 1; i++)
        data[i] = '0';
    data[data_length + N - 1] = '\0';

    printf("\nData padded with n-1 zeros: %s", data);

    crc();

    // Formatting to match your specific output
    check_value[N - 1] = '\0';
    printf("\n\nCRC or Check value is:\n\n%s", check_value);

    for (i = 0; i < N - 1; i++)
        data[data_length + i] = check_value[i];

    data[data_length + N - 1] = '\0';

    printf("\n\nFinal data to be sent %s", data);

    receiver();

    return 0;
}


2.
#include <stdio.h>
#include <math.h>

// Define maximum size for buffers
#define MAX_LEN 32

// --- Function Prototypes ---
int calculate_redundant_bits(int data_len);
void generate_hamming_code(int input[], int data_len, int code[], int *total_len, int parity_count);
int calculate_parity(int position, int code[], int total_len);
int detect_error(int code[], int parity_count, int total_len);

// --- 1. Helper: Calculate number of parity bits needed ---
// Formula: 2^r >= m + r + 1
int calculate_redundant_bits(int data_len)
{
    int i = 0;
    while ((int)pow(2, i) < (data_len + i + 1))
    {
        i++;
    }
    return i;
}

// --- 2. Helper: Calculate Parity for a specific bit position ---
// Checks parity for bits covered by the 'position' (1, 2, 4, 8, etc.)
int calculate_parity(int position, int code[], int total_len)
{
    int count = 0;
    int i = position - 1; // Array index is position - 1

    // Traverse the code word to check parity bits
    // Jump logic: Check 'position' bits, skip 'position' bits
    while (i < total_len)
    {
        for (int j = i; j < i + position; j++)
        {
            // Check boundary and count 1s
            if (j < total_len)
            {
                if (code[j] == 1)
                {
                    count++;
                }
            }
        }
        i = i + 2 * position;
    }

    // Return 0 for Even parity, 1 for Odd parity
    return (count % 2 == 0) ? 0 : 1;
}

// --- 3. Core Logic: Generate the Sent Code ---
void generate_hamming_code(int input[], int data_len, int code[], int *total_len, int parity_count)
{
    *total_len = data_len + parity_count;
    int j = 0; // Pointer for input data array
    int k = 0; // Pointer for power of 2 positions

    // Step A: Place Data Bits and initialize Parity Bits to 0
    for (int i = 0; i < *total_len; i++)
    {
        // If current position is a power of 2 (1, 2, 4, 8...), it's a parity bit
        if (i == ((int)pow(2, k) - 1))
        {
            code[i] = 0;
            k++;
        }
        else
        {
            code[i] = input[j];
            j++;
        }
    }

    // Step B: Calculate values for Parity Bits
    for (int i = 0; i < parity_count; i++)
    {
        int position = (int)pow(2, i);
        int value = calculate_parity(position, code, *total_len);
        code[position - 1] = value;
    }
}

// --- 4. Receiver Logic: Detect Error ---
int detect_error(int code[], int parity_count, int total_len)
{
    int error_pos = 0;

    // Check Parity bits
    for (int i = 0; i < parity_count; i++)
    {
        int position = (int)pow(2, i);
        // If calculate_parity returns 1, it means the even parity check failed
        int value = calculate_parity(position, code, total_len);

        if (value != 0)
        {
            error_pos += position;
        }
    }
    return error_pos;
}

int main()
{
    int input[MAX_LEN];
    int code[MAX_LEN];
    int data_len, total_len, parity_count;

    // --- INPUT ---
    printf("Please enter the length of the Data Word: ");
    scanf("%d", &data_len);

    printf("Please enter the Data Word:\n");
    for (int i = 0; i < data_len; i++)
    {
        scanf("%d", &input[i]);
    }

    // --- CALCULATION ---
    parity_count = calculate_redundant_bits(data_len);
    generate_hamming_code(input, data_len, code, &total_len, parity_count);

    // --- OUTPUT SENDER ---
    printf("\nThe calculated Code Word is: ");
    for (int i = 0; i < total_len; i++)
    {
        printf("%d", code[i]);
    }
    printf("\n");

    // --- INPUT RECEIVER ---
    printf("Please enter the received Code Word:\n");
    for (int i = 0; i < total_len; i++)
    {
        scanf("%d", &code[i]);
    }

    // --- CHECK ERROR ---
    int error_pos = detect_error(code, parity_count, total_len);

    if (error_pos == 0)
    {
        printf("The received Code Word is correct.\n");
    }
    else
    {
        printf("Error at bit position: %d\n", error_pos);
    }

    return 0;
}


3.

#include <stdio.h>
int dist[50][50], temp[50][50], n, i, j, k, x;
void dvr();
int main()
{
    printf("\nEnter the number of nodes : ");
    scanf("%d", &n);
    printf("\nEnter the distance matrix :\n");
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < n; j++)
        {
            scanf("%d", &dist[i][j]);
            dist[i][i] = 0;
            temp[i][j] = j;
        }
        printf("\n");
    }
    dvr();
    printf("enter value of i &j:");
    scanf("%d", &i);
    scanf("%d", &j);
    printf("enter the new cost");
    scanf("%d", &x);
    dist[i][j] = x;
    printf("After update\n\n");
    dvr();
    return 0;
}
void dvr()
{
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            for (k = 0; k < n; k++)
                if (dist[i][k] + dist[k][j] < dist[i][j])
                {
                    dist[i][j] = dist[i][k] + dist[k][j];
                    temp[i][j] = k;
                }
    for (i = 0; i < n; i++)
    {
        printf("\n\nState value for router %d is \n", i + 1);
        for (j = 0; j < n; j++)
            printf("\t\nnode %d via %d Distance%d", j + 1, temp[i][j] + 1, dist[i][j]);
    }
    printf("\n\n");
}

4.

#include <stdio.h>
#include <string.h>
int main()
{
  int count, src_router, i, j, k, w, v, min;
  int cost_matrix[100][100], dist[100], last[100];
  int flag[100];
  printf("\n Enter the no of routers");
  scanf("%d", &count);
  printf("\n Enter the cost matrix values:");
  for (i = 0; i < count; i++)
  {
    for (j = 0; j < count; j++)
    {
      printf("\n%d->%d:", i, j);
      scanf("%d", &cost_matrix[i][j]);
      if (cost_matrix[i][j] < 0)
        cost_matrix[i][j] = 1000;
    }
  }
  printf("\n Enter the source router:");
  scanf("%d", &src_router);
  for (v = 0; v < count; v++)
  {
    flag[v] = 0;
    last[v] = src_router;
    dist[v] = cost_matrix[src_router][v];
  }
  flag[src_router] = 1;
  for (i = 0; i < count; i++)
  {
    min = 1000;
    for (w = 0; w < count; w++)
    {
      if (!flag[w])
        if (dist[w] < min)
        {
          v = w;
          min = dist[w];
        }
    }
    flag[v] = 1;
    for (w = 0; w < count; w++)
    {
      if (!flag[w])
        if (min + cost_matrix[v][w] < dist[w])
        {
          dist[w] = min + cost_matrix[v][w];
          last[w] = v;
        }
    }
  }
  for (i = 0; i < count; i++)
  {
    printf("\n%d==>%d:Path taken:%d", src_router, i, i);
    w = i;
    while (w != src_router)
    {
      printf("\n<--%d", last[w]);
      w = last[w];
    }
    printf("\n Shortest path cost:%d", dist[i]);
  }
}


5.

#include <stdio.h>
#include <conio.h>
int main()
{
    int n;
    int i, j, k;
    int a[10][10], b[10][10];
    printf("\n Enter the number of nodes:");
    scanf("%d", &n);
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < n; j++)
        {
            printf("\n Enter the distance between the host %d - %d:", i + 1, j + 1);
            scanf("%d", &a[i][j]);
        }
    }
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < n; j++)
        {
            printf("%d\t", a[i][j]);
        }
        printf("\n");
    }
    for (k = 0; k < n; k++)
    {
        for (i = 0; i < n; i++)
        {
            for (j = 0; j < n; j++)
            {
                if (a[i][j] > a[i][k] + a[k][j])
                {
                    a[i][j] = a[i][k] + a[k][j];
                }
            }
        }
    }
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < n; j++)
        {
            b[i][j] = a[i][j];
            if (i == j)
            {
                b[i][j] = 0;
            }
        }
    }
    printf("\n The output matrix:\n");
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < n; j++)
        {
            printf("%d\t", b[i][j]);
        }
        printf("\n");
    }
    getch();
}




